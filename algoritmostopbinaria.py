# -*- coding: utf-8 -*-
"""AlgoritmosTopBinaria.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N57G32zggRxUJpAgC_q-iHP_zybPeOO4

<center>OPERACIONES DE CONJUNTOS</center>

*1. Conjunto de partes*
"""

#https://towardsdatascience.com/the-subsets-powerset-of-a-set-in-python-3-18e06bd85678
from itertools import chain, combinations

def power_set(lista):
    return list(list(x) for x in chain.from_iterable(combinations(lista, r) for r in range(len(lista) + 1)))

X = ['a','b','c','d']
Y = ['e','f','g','h','i']

print(power_set(X))
print("")
print(power_set(Y))

"""*2. Producto cartesiano*"""

from itertools import product
def cartesian_product(X,Y):
    return list(list(x) for x in product(X, Y))

print(cartesian_product(power_set(X),power_set(Y)))

"""*2. Complemento componente a componente. $(X\setminus A, Y \setminus B)$*"""

def binary_complement(X,Y,pair):
  X_complement = []
  Y_complement = []
  for element in X:
        if element not in pair[0]:
            X_complement.append(element)
  for element in Y:
        if element not in pair[1]:
            Y_complement.append(element)
  return [X_complement,Y_complement]

X = ['a','b','c','d']
Y = ['e','f','g','h','i']

binary_complement(X,Y,[['b','c','d'],['f','g','h','i']])

"""

*3. Unión binaria. $(A_1,B_1)\cup (A_2 ,B_2) = (A_1 \cup A_2 , B_1 \cup B_2)$*"""

def binary_union(pair1,pair2):
  sets1 = [set(x) for x in pair1]
  sets2 = [set(x) for x in pair2]
  union1 = list(sets1[0].union(sets2[0]))
  union2 = list(sets1[1].union(sets2[1]))
  union = [union1,union2]
  return union

A = [['a','b','c','d'],['e','f','g']]
B = [[1,2,3],[4,5]]
B2 = [['a','h','i'],['e','k','l']]

print(binary_union(A,B))
print("--------------")
print(binary_union(A,B2))
print(binary_union(B2,A))

"""*3. Intersección binaria. $(A_1,B_1)\cap (A_2 ,B_2) = (A_1 \cap A_2 , B_1 \cap B_2)$*"""

def binary_intersection(pair1,pair2):
  sets1 = [set(x) for x in pair1]
  sets2 = [set(x) for x in pair2]
  union1 = list(sets1[0].intersection(sets2[0]))
  union2 = list(sets1[1].intersection(sets2[1]))
  union = [union1,union2]
  return union

A = [['a','b','c','d'],['e','f','g']]
B = [[1,2,3],[4,5]]
B2 = [['a','h','i'],['e','k','l']]
print(binary_intersection(A,B))
print("--------------")
print(binary_intersection(A,B2))
print(binary_intersection(B2,A))

"""

---------


<center>CERRADOS Y ABIERTOS</center>


*1. Cerrados*"""

X = ['a','b','c','d']
Y = ['e','f','g','h','i']
M = [[[],[]],[X,Y],[['a'],['e']],[['b'],['f']],[['a','b'],['e','f']]]

def closed_sets(X,Y,M): #subsets is the set of all posible subsets (A,B) of (X,Y)
    closed = []
    subsets = cartesian_product(power_set(X),power_set(Y)) #we analize every pair in P(X)xP(Y)
    for pair in subsets:
        complement = binary_complement(X,Y,pair)
        if complement in M:
            closed.append(pair)
    return closed

for i in closed_sets(X,Y,M):
    print(i,'\n')

"""Abiertos: son los elementos de $\mathcal{M}$

---
<center> VERIFICANDO QUE UN $\mathcal{M}$ DADO ES TOPOLOGÍA BINARIA </center>

*Necesitamos primero garantizar que dada una parejas, esta no se encuentra en el conjunto (igual o con orden distinto)*
"""

def repeated_pair(s,element):
    for pair in s:
        if set(element[0]) == set(pair[0]) and set(element[1]) == set(pair[1]):
            return True
    return False

M = [[['a'], []], [['a'], [1]], [['a', 'b'], [3]], [['c', 'd'], [2]], [['a', 'c', 'd'], [2]], [['a', 'b'], [1, 3]], [['a', 'c', 'd'], [1, 2]], [['a', 'b', 'c', 'd'], [2, 3]], [['a', 'b', 'c', 'd'], [1, 2, 3]]]

print(repeated_pair(M, [['d', 'c', 'a'], [2]]))

"""*1. Verificar que todas las posibles intersecciones pertenecen a $\mathcal{M}$*"""

X = ['a','b','c','d']
Y = ['e','f','g','h','i']
M = [[[],[]],[X,Y],[['a'],['e']],[['b'],['f']],[['a','b'],['e','f']]]
#X = ['a','b','c','d']
#Y= [1,2,3]
#M = [[['a'],[]],[['a'],[1]],[['a','b'],[3]],[['c','d'],[2]],[['a','c','d'],[2]],[['a','b'],[1,3]],[['a','c','d'],[1,2]],[['a','b','c','d'],[2,3]],[['a','b','c','d'],[1,2,3]]]

def verify_intersection(M):
  v = True
  for i in range(len(M)-1):
    for j in range(i+1,len(M)):
      intersection = binary_intersection(M[i],M[j])
      if repeated_pair(M, intersection) == False:
        return False #exit the loop if an intersections doesn't belong
  return v
verify_intersection(M)

"""*2. Verificar que todas las posibles uniones pertenecen a $\mathcal{M}$*


"""

M = [[[],[]],[X,Y],[['a'],['e']],[['b'],['f']],[['a','b'],['e','f']]]
#M = [[['a'],[]],[['a'],[1]],[['a','b'],[3]],[['c','d'],[2]],[['a','c','d'],[2]],[['a','b'],[1,3]],[['a','c','d'],[1,2]],[['a','b','c','d'],[2,3]],[['a','b','c','d'],[1,2,3]]]

def verify_union(M):
  v = True
  for i in range(len(M)-1):
    for j in range(i+1,len(M)):
      union = binary_union(M[i],M[j])
      if repeated_pair(M,union) == False:
        return False
  return v
verify_union(M)

"""

*3. Verificar si $M$ es una topología binaria*
"""

X = ['a','b','c','d']
Y = ['e','f','g','h','i']
M = [[[],[]],[X,Y],[['a'],['e']],[['b'],['f']],[['a','b'],['e','f']]]
#X = ['a','b','c','d']
#Y= [1,2,3]
#M = [[['a'],[]],[['a'],[1]],[['a','b'],[3]],[['c','d'],[2]],[['a','c','d'],[2]],[['a','b'],[1,3]],[['a','c','d'],[1,2]],[['a','b','c','d'],[2,3]],[['a','b','c','d'],[1,2,3]]]

def is_bin_topology(M,X,Y):
  if verify_intersection(M) and verify_union(M) and [[], []] in M and [X,Y] in M:
    return True
  else:
    return False

is_bin_topology(M,X,Y)

"""---
<center> CREACIÓN DE UNA TOPOLOGÍA BINARIA A PARTIR DE UNA BASE</center>

*Añadir uniones e intersecciones adicionales*
"""

#M = [[[],[]],[[1,2],[1,2,3]],[[1],[1]],[[2],[2]],[[3],[3]],[[],[3]]]
#X = [1,2]
#Y = [1,2,3]
#M = [[['a'],[1]],[['a','b'],[3]],[['c','d'],[2]]]
#X = ['a','b','c','d']
#Y = [1,2,3]

X = ['c_1','c_2','c_3','c_4']
Y = ['p_1','p_2','p_3','p_4']
M = [[['c_4'],['p_4']],[['c_1','c_2','c_3'],['p_1','p_2','p_3']],[['c_1','c_2'],['p_1','p_3','p_4']],[['c_3','c_4'],['p_1']],[['c_1','c_2'],['p_2','p_3','p_4']]]

def extended_intersection(S):
  for i in range(len(S)-1):
    for j in range(i+1,len(S)):
      if repeated_pair(S,binary_intersection(S[i],S[j])) == False:
        S.append(binary_intersection(S[i],S[j]))
        #print("intersection of: ",S[i],"and",S[j],"generates--->",binary_intersection(S[i],S[j]))
  #return S

def extended_union(S):
  for i in range(len(S)-1):
    for j in range(i+1,len(S)):
      if repeated_pair(S,binary_union(S[i],S[j])) == False:
        S.append(binary_union(S[i],S[j]))
        #print("union of: ",S[i],"and",S[j],"generates--->",binary_union(S[i],S[j]))
  #return S

print("longitud inicial -> ",len(M))
while verify_intersection(M) != True:
  extended_intersection(M)

print("longitud con intersecciones -> ",len(M))
print(M)

while verify_union(M) != True:
  extended_union(M)
print("longitud con uniones -> ",len(M))
print(M)

basesita = [[['c_4'],['p_4']],[['c_1','c_2','c_3'],['p_1','p_2','p_3']],[['c_1','c_2'],['p_1','p_3','p_4']],[['c_3','c_4'],['p_1']],[['c_1','c_2'],['p_2','p_3','p_4']],
           [[],[]],[[],['p_4']],[['c_4'],[]],[['c_1','c_2'],['p_1','p_3']],[['c_3'],['p_1']],[['c_1','c_2'],['p_2','p_3']],
           [[],['p_1']] ,[['c_1','c_2'],['p_3','p_4']],[['c_1','c_2'],['p_3']],[['c_2'],['p_3']],[['c_1'],['p_3']]]
print(repeated_pair(basesita,[['c_1'],['p_3']]))

"""*Verificar que un elmento del producto cartesiano usual pertenece a alguna pareja*"""

X = ['a','b','c']
Y = [1,2,3]

prod = cartesian_product(X,Y)
print(prod)

delta = [[['a'],[1]],[['b'],[2,3]],[['b','c'],[2]]]
def element_in_pair(element,base):
  found1 = False
  for pair in base:
    if element[0] in pair[0]:
      found1 = True
      break
  found2 = False
  for pair in base:
    if element[1] in pair[1]:
      found2 = True
      break
  if found1 == True and found2 == True:
    return True
  else:
    return False

element_in_pair(['b', 1],delta)

def cartesian_in_base(cartesian,base):
  for element in cartesian:
    if not element_in_pair(element,base):
      return False
  return True

cartesian_in_base(prod,[[['b'],[2,3]],[['b','c'],[2]]])
#cartesian_in_base(prod,delta)

"""*2. generar topología binaria*

"""

#M = [[[],[]],[[1,2],[1,2,3]],[[1],[1]],[[2],[2]],[[3],[3]],[[],[3]]]
#X = [1,2]
#Y = [1,2,3]
##########
#M = [[['a'],[1]],[['a','b'],[3]],[['c','d'],[2]]]
#X = ['a','b','c','d']
#Y = [1,2,3]
#M as delta
M = [[[1],[1]],[[2],[2]],[[3],[3]],[[],[3]]]
X = [1,2]
Y = [1,2,3]

def generate_bin_topology(X,Y,M):
  cartesian = cartesian_product(X,Y)
  if cartesian_in_base(cartesian,M):
    while verify_intersection(M) != True:
      extended_intersection(M)
    while verify_union(M) != True:
      extended_union(M)
    if [[], []] not in M:
      M.append([[], []])
    return M
  else:
    return "No es posible"

generate_bin_topology(X,Y,M)

"""------------------------------------------------------------------------------

<center>INTERIOR Y CLAUSURA</center>

*Necesitamos poder verificar si una pareja $(A,B)$ esta contenida en otra pareja $(C,D)$*
"""

A = [[1,2],[3,4]]
B = [[1,2,5],[3]]

def is_contained(pair1, pair2): #verifica si pair1 esta contenido en pair2
    return all(elem in pair2[0] for elem in pair1[0]) and all(elem in pair2[1] for elem in pair1[1])

print(is_contained(A,B))

"""*Union e interseccion de varias parejas*"""

def multiple_intersection(lists_to_intersect):
  sets = [set(x) for x in lists_to_intersect]
  intersection_result = sets[0]
  for s in sets[1:]:
    intersection_result = intersection_result.intersection(s)
  return list(intersection_result)

def multiple_union(lists_to_union):
    sets = [set(x) for x in lists_to_union]
    union_result = sets[0]
    for s in sets[1:]:
        union_result = union_result.union(s)
    return list(union_result)

"""*1. Interior*"""

from itertools import product

X = ['a','b','c','d']
Y = ['e','f','g','h','i']
M = [[[],[]],[X,Y],[['a'],['e']],[['b'],['f']],[['a','b'],['e','f']]]

def interior(X,Y,M,pair):
  pairs = []
  power_setX = power_set(X)
  power_setY = power_set(Y)
  cartesianproduct = cartesian_product(power_setX,power_setY)
  """
  for element in cartesianproduct:
    if is_contained(element,pair) and element in M: #list of pairs that satisfy the definition
      pairs.append(element)
  """
  for element in M:
    if is_contained(element,pair):
      pairs.append(element)
  first_components = [pair[0] for pair in pairs]
  second_components = [pair[1] for pair in pairs]
  first_component = multiple_union(first_components)
  second_component = multiple_union(second_components)
  return [first_component,second_component]

#interior(X,Y,M,[['a','c'],['e','g']])
#interior(X,Y,M,[['a','b','c'],['e','f','g']])
interior(X,Y,M,[['a','c','d'],['f','g']])

"""*2. Clausura*"""

def closure(X,Y,M,pair):
  pairs = []
  power_setX = power_set(X)
  power_setY = power_set(Y)
  cartesianproduct = cartesian_product(power_setX,power_setY)
  for element in cartesianproduct:
    if is_contained(pair,element) and binary_complement(X,Y,element) in M:
      pairs.append(element)
  first_components = [pair[0] for pair in pairs]
  second_components = [pair[1] for pair in pairs]
  first_component = multiple_intersection(first_components)
  second_component = multiple_intersection(second_components)
  return [first_component,second_component]

closure(X,Y,M,[['a','c'],['e','g']])

"""

---

## __Tipos especiales de abiertos y cerrados__
"""

M = [[[1], [1]],
 [[2], [2]],
 [[3], [3]],
 [[], [3]],
 [[], []],
 [[1, 2], [1, 2]],
 [[1, 3], [1, 3]],
 [[1], [1, 3]],
 [[2, 3], [2, 3]],
 [[2], [2, 3]],
 [[1, 2, 3], [1, 2, 3]],
 [[1, 2], [1, 2, 3]]]
X = [1,2]
Y = [1,2,3]
power_setX = power_set(X)
power_setY = power_set(Y)
cartesianproduct = cartesian_product(power_setX,power_setY)

print('\n'+"Regular open sets: "+'\n')
for pair in cartesianproduct:
  if pair == interior(X,Y,M,closure(X,Y,M,pair)):
    print(pair)

print('\n'+"Regular closed sets: "+'\n')
for pair in cartesianproduct:
  if pair == closure(X,Y,M,interior(X,Y,M,pair)):
    print("is weird",pair)

print('\n'+"Semi preopen sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(pair, closure(X,Y,M,interior(X,Y,M,closure(X,Y,M,pair)))):
    print(pair)

print('\n'+"Semi preclosed sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(interior(X,Y,M,closure(X,Y,M,interior(X,Y,M,pair))),pair):
    print(pair)

print('\n'+"Semi open sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(pair, closure(X,Y,M,interior(X,Y,M,pair))):
    print(pair)

print('\n'+"Semi closed sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(interior(X,Y,M,closure(X,Y,M,pair)),pair):
    print(pair)

print('\n'+"pre open sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(pair,interior(X,Y,M,closure(X,Y,M,pair))):
    print(pair)


print('\n'+"pre closed sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(closure(X,Y,M,interior(X,Y,M,pair)),pair):
    print(pair)

print('\n'+"alpha closed sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(pair,interior(X,Y,M,closure(X,Y,M,interior(X,Y,M,pair)))):
    print(pair)

def clopen_classification(X,Y,M,pair):
  cartesianproduct = cartesian_product(power_set(X),power_set(Y))



M = [[[1], [1]],
 [[2], [2]],
 [[3], [3]],
 [[], [3]],
 [[], []],
 [[1, 2], [1, 2]],
 [[1, 3], [1, 3]],
 [[1], [1, 3]],
 [[2, 3], [2, 3]],
 [[2], [2, 3]],
 [[1, 2, 3], [1, 2, 3]],
 [[1, 2], [1, 2, 3]]]
X = [1,2]
Y = [1,2,3]
power_setX = power_set(X)
power_setY = power_set(Y)
cartesianproduct = cartesian_product(power_setX,power_setY)

print('\n'+"Regular open sets: "+'\n')
for pair in cartesianproduct:
  if pair == interior(X,Y,M,closure(X,Y,M,pair)):
    print(pair)

print('\n'+"Regular closed sets: "+'\n')
for pair in cartesianproduct:
  if pair == closure(X,Y,M,interior(X,Y,M,pair)):
    print("is weird",pair)

print('\n'+"Semi preopen sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(pair, closure(X,Y,M,interior(X,Y,M,closure(X,Y,M,pair)))):
    print(pair)

print('\n'+"Semi preclosed sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(interior(X,Y,M,closure(X,Y,M,interior(X,Y,M,pair))),pair):
    print(pair)

print('\n'+"Semi open sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(pair, closure(X,Y,M,interior(X,Y,M,pair))):
    print(pair)

print('\n'+"Semi closed sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(interior(X,Y,M,closure(X,Y,M,pair)),pair):
    print(pair)

print('\n'+"pre open sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(pair,interior(X,Y,M,closure(X,Y,M,pair))):
    print(pair)


print('\n'+"pre closed sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(closure(X,Y,M,interior(X,Y,M,pair)),pair):
    print(pair)

print('\n'+"alpha closed sets: "+'\n')
for pair in cartesianproduct:
  if is_contained(pair,interior(X,Y,M,closure(X,Y,M,interior(X,Y,M,pair)))):
    print(pair)

print(closure(X,Y,M,[[], []]))

print(interior(X,Y,M,[[], []]))

print(closure(X,Y,M,[X, Y]))

print(interior(X,Y,M,[X, Y]))

"""## __$\alpha, \beta$ sets__"""



"""## __Definition 8__"""

def regular_closed_set(X,Y,M):
  if pair == closure(X,Y,M,interior(X,Y,M,pair)):
    return True

def alpha_ast_set(X,Y,M,pair):
  if interior(X,Y,M,pair) == interior(X,Y,M,closure(X,Y,M,interior(X,Y,M,pair))):
    return True

def t_set(X,Y,M,pair):
  if interior(X,Y,M,pair) == interior(X,Y,M,closure(X,Y,M,pair)):
    return True
  else:
    return False


def s_set(X,Y,M,pair):
  if interior(X,Y,M,pair) == closure(X,Y,M,interior(X,Y,M,pair)):
    return True

def beta_ast_set(X,Y,M,pair):
  if interior(X,Y,M,pair) == closure(X,Y,M,interior(X,Y,M,closure(X,Y,M,pair))):
    return True

def A_set(X,Y,M,pair):
  regular_closed_sets = []
  for element in cartesian_product(power_set(X),power_set(Y)):
    if regular_closed_set(X,Y,M,element):
      regular_closed_sets.append(element)
  for pair1 in regular_closed_sets:
    for pair2 in M:
      if pair == binary_intersection(pair1,pair2):
        return True
  return False

def B_set(X,Y,M,pair):
  t_sets = []
  for element in cartesian_product(power_set(X),power_set(Y)):
    if t_set(X,Y,M,element) == True:
      t_sets.append(element)
  for pair1 in t_sets:
    for pair2 in M:
      if pair == binary_intersection(pair2,pair1):
        return True
  return False

def C_set(X,Y,M,pair):
  alpha_ast_sets = []
  for element in cartesian_product(power_set(X),power_set(Y)):
    if alpha_ast_set(X,Y,M,element):
      alpha_ast_sets.append(element)
  for pair1 in alpha_ast_sets:
    for pair2 in M:
      if pair == binary_intersection(pair1,pair2):
        return True
  return False

def locally_closed_set(X,Y,M,pair):
  for pair1 in closed_sets(X,Y,M):
    for pair2 in M:
      if pair == binary_intersection(pair1,pair2):
        return True
  return False

def beta_set(X,Y,M,pair):
  beta_ast_sets = []
  for element in cartesian_product(power_set(X),power_set(Y)):
    if beta_ast_set(X,Y,M,element):
      beta_ast_sets.append(element)
  for pair1 in beta_ast_sets:
    for pair2 in M:
      if pair == binary_intersection(pair1,pair2):
        return True
  return False


def p_set(X,Y,M,pair):
  s_sets = []
  for element in cartesian_product(power_set(X),power_set(Y)):
    if s_set(X,Y,M,element):
      s_sets.append(element)
  for pair1 in s_sets:
    for pair2 in M:
      if pair == binary_intersection(pair1,pair2):
        return True
  return False



X = [1,2]
Y = [5]
M = [
 [[], []],
 [X, Y],
 [[1],Y],
 [[2], []]]
print("M",M)
power_setX = power_set(X)
power_setY = power_set(Y)
cartesianproduct = cartesian_product(power_setX,power_setY)

print('\n'+"B sets: "+'\n')
for pair in cartesianproduct:
  if B_set(X,Y,M,pair):
    print(pair)

print('\n'+"C sets: "+'\n')
for pair in cartesianproduct:
  if C_set(X,Y,M,pair):
    print(pair)

print('\n'+"locally closed sets: "+'\n')
for pair in cartesianproduct:
  if locally_closed_set(X,Y,M,pair):
    print(pair)

print('\n'+"beta sets: "+'\n')
for pair in cartesianproduct:
  if locally_closed_set(X,Y,M,pair):
    print(pair)

print('\n'+"p sets: "+'\n')
for pair in cartesianproduct:
  if p_set(X,Y,M,pair):
    print(pair)

X = [1,2]
Y = [5,6]
M = [
 [[], []],
 [X, Y],
 [[1],Y],
 [[2], []]]

power_setX = power_set(X)
power_setY = power_set(Y)
cartesianproduct = cartesian_product(power_setX,power_setY)

t_sets = []
for element in cartesian_product(power_set(X),power_set(Y)):
  if t_set(X,Y,M,element) == True:
    t_sets.append(element)

print(t_sets)

X = [1,2]
Y = [5]
M = [
 [[], []],
 [X, Y],
 [[1],Y],
 [[2], []]]

power_setX = power_set(X)
power_setY = power_set(Y)
cartesianproduct = cartesian_product(power_setX,power_setY)
print(closed_sets(X,Y,M))
for element in cartesianproduct:
  print(element,"int--->",interior(X,Y,M,element),"clos->",closure(X,Y,M,element),"---",interior(X,Y,M,closure(X,Y,M,element)))

def special_sets(X,Y,M,pair):
  cartesianproduct = cartesian_product(power_setX,power_setY)
  binary_reg_closed = []
  binary_t = []
  for pair in cartesianproduct:
    if pair == closure(X,Y,M,interior(X,Y,M,pair)):
      binary_reg_closed.append(pair)
  for pair in cartesianproduct:
    if pair == closure(X,Y,M,interior(X,Y,M,pair)):
      binary_reg_closed.append(pair)

X = ['c_1','c_2','c_3','c_4']
Y = ['p_1','p_2','p_3','p_4']
M = [[['c_4'],['p_4']],[['c_1','c_2','c_3'],['p_1','p_2','p_3']],[['c_1','c_2'],['p_1','p_3','p_4']],[['c_3','c_4'],['p_1']],[['c_1','c_2'],['p_2','p_3','p_4']]]
#generate_bin_topology(X,Y,M)
print(generate_bin_topology(X,Y,M))
print("---------------")
print(len(generate_bin_topology(X,Y,M)))
fo

basesita = [[['c_4'],['p_4']],[['c_1','c_2','c_3'],['p_1','p_2','p_3']],[['c_1','c_2'],['p_1','p_3','p_4']],[['c_3','c_4'],['p_1']],[['c_1','c_2'],['p_2','p_3','p_4']],
            [[],[]],[[], ['p_4']],[['c_4'], []],[['c_1', 'c_2'], ['p_1', 'p_3']],[['c_3'], ['p_1']],[['c_1', 'c_2'], ['p_3', 'p_2']],[[], ['p_1']],
            [['c_1', 'c_2'], ['p_3', 'p_4']], [['c_1', 'c_2'], ['p_3']],[['c_4', 'c_1', 'c_2', 'c_3'], ['p_1', 'p_3', 'p_4', 'p_2']],[['c_4', 'c_1', 'c_2'], ['p_1', 'p_3', 'p_4']],
            [['c_4', 'c_3'], ['p_1', 'p_4']],[['c_4', 'c_1', 'c_2'], ['p_3', 'p_4', 'p_2']],[['c_4'], ['p_1', 'p_4']], [['c_4', 'c_1', 'c_2'], ['p_3', 'p_4']],
            [['c_1', 'c_3', 'c_2'], ['p_1', 'p_4', 'p_2', 'p_3']],[['c_4', 'c_1', 'c_3', 'c_2'], ['p_1', 'p_3', 'p_2']],[['c_4', 'c_1', 'c_2', 'c_3'], ['p_1', 'p_3', 'p_4']],
            [['c_1', 'c_2'], ['p_1', 'p_4', 'p_2', 'p_3']],[['c_1', 'c_2', 'c_3'], ['p_1', 'p_3', 'p_4']],[['c_4', 'c_1', 'c_2'], ['p_1', 'p_4', 'p_2', 'p_3']],
            [['c_1', 'c_4', 'c_3', 'c_2'], ['p_1', 'p_3']] ,[['c_3'], ['p_1', 'p_4']],[[], ['p_1', 'p_4']],[['c_4', 'c_1', 'c_2'], ['p_1', 'p_3']], [['c_4', 'c_1', 'c_2'], ['p_3', 'p_2']],
            [['c_4'], ['p_1']],[['c_4', 'c_1', 'c_2'], ['p_3']], [['c_1', 'c_2', 'c_3'], ['p_1', 'p_3']],[['c_1', 'c_2'], ['p_1', 'p_3', 'p_2']]]

print(len(basesita))

[[{},{2,4}],[{1},{3}]]

from google.colab import files

# Upload a file and get the content
uploaded = files.upload()

# Extract the filename and content
filename = list(uploaded.keys())[0]
content = uploaded[filename].decode('utf-8')

M = []
lines = content.split('\n')
partition1 = lines[0:1]
partition2 = lines[2::]
X = eval(lines[0])
Y = eval(lines[1])
for element in lines[2::]:
    if element == '[X,Y]':
        M.append([X, Y])
    else:
        M.append(eval(element))

print("X:", X)
print("Y:", Y)
print("M:", M)